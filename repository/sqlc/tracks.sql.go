// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tracks.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const getMatchingTracks = `-- name: GetMatchingTracks :many
select t.id, t.name from "public"."tracks" t where t.name ilike $1
`

type GetMatchingTracksRow struct {
	ID   int32
	Name string
}

func (q *Queries) GetMatchingTracks(ctx context.Context, name string) ([]GetMatchingTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchingTracks, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchingTracksRow
	for rows.Next() {
		var i GetMatchingTracksRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNonExistentTrackIDs = `-- name: GetNonExistentTrackIDs :many
with s as (select unnest($1::integer[]) id)
select s.id::integer
from s
left join tracks as t on s.id = t.id
where t.id is null
`

func (q *Queries) GetNonExistentTrackIDs(ctx context.Context, trackIds []int32) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getNonExistentTrackIDs, pq.Array(trackIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var s_id int32
		if err := rows.Scan(&s_id); err != nil {
			return nil, err
		}
		items = append(items, s_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrack = `-- name: GetTrack :one
select
   t.id, t.name, t.type, t.gpxfile_id, t.created_at, t.user_id,
   f.time,
  SUM(ST_Length(s.geometry::geography))::double precision AS track_length_meters
from "public"."tracks" t
join "public"."gpxfiles" f on t.gpxfile_id = f.id
join public.segments s ON t.id = s.track_id
where t.id = $1
group by t.id, f.time
`

type GetTrackRow struct {
	ID                int32
	Name              string
	Type              Tracktype
	GpxfileID         int32
	CreatedAt         time.Time
	UserID            int32
	Time              sql.NullTime
	TrackLengthMeters float64
}

func (q *Queries) GetTrack(ctx context.Context, id int32) (GetTrackRow, error) {
	row := q.db.QueryRowContext(ctx, getTrack, id)
	var i GetTrackRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.GpxfileID,
		&i.CreatedAt,
		&i.UserID,
		&i.Time,
		&i.TrackLengthMeters,
	)
	return i, err
}

const getTracks = `-- name: GetTracks :many
SELECT 
    t.id, t.name, t.type, t.gpxfile_id, t.created_at, t.user_id,
    u.id, u.username, u.hashed_password, u.created_at,
    SUM(ST_Length(s.geometry::geography))::double precision AS track_length_meters
FROM 
    public.tracks t
JOIN 
    public.segments s ON t.id = s.track_id
JOIN public.users u ON t.user_id = u.id
GROUP BY 
    t.id, u.id
ORDER BY 
    t.created_at desc
`

type GetTracksRow struct {
	Track             Track
	User              User
	TrackLengthMeters float64
}

func (q *Queries) GetTracks(ctx context.Context) ([]GetTracksRow, error) {
	rows, err := q.db.QueryContext(ctx, getTracks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTracksRow
	for rows.Next() {
		var i GetTracksRow
		if err := rows.Scan(
			&i.Track.ID,
			&i.Track.Name,
			&i.Track.Type,
			&i.Track.GpxfileID,
			&i.Track.CreatedAt,
			&i.Track.UserID,
			&i.User.ID,
			&i.User.Username,
			&i.User.HashedPassword,
			&i.User.CreatedAt,
			&i.TrackLengthMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTrack = `-- name: InsertTrack :one
insert into "public"."tracks" (gpxfile_id, type, name, user_id) values ($1, $2, $3, $4) returning id
`

type InsertTrackParams struct {
	GpxfileID int32
	Type      Tracktype
	Name      string
	UserID    int32
}

func (q *Queries) InsertTrack(ctx context.Context, arg InsertTrackParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertTrack,
		arg.GpxfileID,
		arg.Type,
		arg.Name,
		arg.UserID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
